# 확률적 분석과 랜덤화된 알고리즘
- 입력이 충분히 커지면 수행시간 증가의 차수만 중요해진다.
- 알고리즘의 점근적 효율성을 판단할 수 있는 표기법을 살펴본다.
- 알고리즘 분석에 자주 등장하는 함수의 특성을 살펴본다.

### 예시 문제: 고용 문제
- 새로운 직원을 고용해야 한다.
- 직업 소개소에 소개료를 지불하고 매일 1명을 소개받는다.
- 소개받은 사람을 고용하려면, 현재 사람을 해고하고, 더 많은 소개료를 지불해야한다.
- 각 지원자를 면담하여 현재 직원보다 일을 잘할지 판단해야 한다.

```
HIRE-ASSISTANT
best = 0		// 0번은 가장 낮은 점수를 갖는 가상의 지원자다.
for i = 1 to n
	지원자 i를 면접한다.
	if 지원자 i가 best 보다 나은가?
		best = i
		지원자 i를 고용한다.
```
- 면접 비용: c<sub>i</sub>
- 고용 비용: c<sub>h</sub>
- 고용된 사람의 수: m
- 수행시간: O(c<sub>i</sub>n + c<sub>h</sub>m)
- 언제나 n명 면접을 봐야하므로 면접 비용은 항상 c<sub>i</sub>n이다.
- 그러므로 고용비용 c<sub>h</sub>m 을 낮추는 것에 초점을 맞춘다.

#### 최악의 경우 분석
- 매번 기존 사람을 해고하고, 새로운 사람을 고용하는 경우
- O(c<sub>h</sub>n)
- 그러나 매 순서마다 더 잘하는 사람이 오지 않는다고 보는 것이 더 타당하므로 확률적으로 분석

#### 확률적 분석
- 입력 분포에 대한 정보 이용 or 가정 필요
- **모든 수행시간의 평균**을 구한다.
- 고용 문제에서는 지원자가 무작위 순서로 온다고 가정.
	- 누가 더 뛰어난지 알 수 있다. (전체 순서를 알고 있다.)
- 이렇게 무작위로 사람을 나열하는 경우의 수는 n!
- n!개의 수열이 모두 같은 확률로 일어날 수 있다.

#### 랜덤화된 알고리즘
- 확률과 무작위성을 통해 알고리즘 일부가 랜덤하게 동작하도록 한다.
- n명의 지원자가 있고 그 목록이 갖고 있을 때, 매일 면접 볼 1명을 무작위로 선택한다고 가정한다.
- 난수 생성기를 이용한다. (사실은 난수처럼 "보이는" 수를 리턴하는 결정론적 알고리즘이다.)
- **기대 수행시간**: 난수가 리턴하는 값의 분포에 대한 수행시간

입력 값의 분포를 알 땐 평균수행시간, 모를 땐 기대수행시간을 분석한다.
