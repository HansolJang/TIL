# 삽입정렬
1. 의사코드로 구현
2. 올바르게 정렬되는지 확인
3. 수행시간 분석
4. 분할정복 소개


![](https://www.dotnetlovers.com/images/coolnikhilj22a2b418fe-0d4f-4c2d-828c-09e0a74ad630.jpg?1/15/2016%202:05:48%20AM)

- 크기가 작은 정렬에 효율적이다.
- 카드를 한장 씩 가져와 왼손에 든 카드 중 적절한 위치에 넣는다.
- 왼손에 든 카드는 항상 정렬이 되어있다.

![](https://upload.wikimedia.org/wikipedia/commons/e/ea/Insertion_sort_001.PNG)

![](https://cdn-images-1.medium.com/max/1600/1*vEBirVKE-Iun9WpDrI8wFg.png)

##### 루프불변성
- 알고리즘이 타당한 이유를 쉽게 이해할 수 있도록 하기 위해 사용

- 초기 조건: 루프 전체가 **시작하기 전**에 루프 불변성이 참이어야 한다.
- 유지 조건: 루프의 **반복이 시작**되기 전에 루프 불변성이 참이었다면, **다음 반복이 시작되기 전**까지도 계속 참이어야 한다.
- 종료 조건: 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다.

~~~
A[1..j - 1]은 루프가 반복될 때마다 정렬된다.
~~~
- 초기 조건: 시작 전엔 `A[1]` 하나의 원소를 가지므로 정렬되어 있다.
- 유지 조건: 매 반복시 불변성이 유지되는지 살펴본다. 
	- `A[j]`의 올바른 위치를 찾을 때까지 `A[j-1],A[j-2],...` 오른쪽으로 한칸씩 swap. `j`가 `1`씩 증가하면서 다음 반복에서 루프 불변성이 유지된다.
- 종료 조건: `j`가 `n + 1`일 때 for 루프가 종료되는데, 이때 A[1..n]은 정렬된 상태이므로 이 알고리즘은 타당하다.


```
코드 kotlin 추가 예정
```

##### 알고리즘의 분석
- 알고리즘 수행 상황 정의: 단일 프로세서 + 랜덤 접근 기계(RAM) (명령어 순차적 실행)
- RAM
	- 산술연산(덧셈, 뺄셈, 곱셈, 나눗셈, 나머지, 올림, 내림), 데이터 이동(CRU), 제어 연산(조건분기, 무조건분기, 함수 호출, 리턴)에는 상수 시간이 걸린다.
	- 메모리 계층을 고려하지 않는다. (캐시, 가상 메모리 포함 X)

#### 삽입 정렬의 분석
- 입력이 많을 수록 오래 걸린다. 
- 같은 입력이라도 초기에 얼마나 정렬되어 있느냐에 따라 수행시간이 달라진다.

##### 입력 크기: 문제마다 다르다
- 입력 항목의 개수 (배열의 크기)
- 입력을 이진수로 표현했을 때 필요한 비트수
- 하나의 입력을 두개의 값으로 표현할 경우 (그래프의 노드와 간선)

##### 수행 시간
- 기본 연산 개수
- 실행 단계의 횟수
- 각 행을 수행하는 데 상수시간이 소요된다고 정의하자


