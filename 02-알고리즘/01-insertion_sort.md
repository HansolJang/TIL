# 삽입정렬
1. 의사코드로 구현
2. 올바르게 정렬되는지 확인
3. 수행시간 분석
4. 분할정복 소개


![](https://www.dotnetlovers.com/images/coolnikhilj22a2b418fe-0d4f-4c2d-828c-09e0a74ad630.jpg?1/15/2016%202:05:48%20AM)

- 크기가 작은 정렬에 효율적이다.
- 카드를 한장 씩 가져와 왼손에 든 카드 중 적절한 위치에 넣는다.
- 왼손에 든 카드는 항상 정렬이 되어있다.

![](https://upload.wikimedia.org/wikipedia/commons/e/ea/Insertion_sort_001.PNG)

![](https://cdn-images-1.medium.com/max/1600/1*vEBirVKE-Iun9WpDrI8wFg.png)

##### 루프불변성
- 알고리즘이 타당한 이유를 쉽게 이해할 수 있도록 하기 위해 사용

- 초기 조건: 루프 전체가 **시작하기 전**에 루프 불변성이 참이어야 한다.
- 유지 조건: 루프의 **반복이 시작**되기 전에 루프 불변성이 참이었다면, **다음 반복이 시작되기 전**까지도 계속 참이어야 한다.
- 종료 조건: 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다.

~~~
A[1..j - 1]은 루프가 반복될 때마다 정렬된다.
~~~
- 초기 조건: 시작 전엔 `A[1]` 하나의 원소를 가지므로 정렬되어 있다.
- 유지 조건: 매 반복시 불변성이 유지되는지 살펴본다. 
	- `A[j]`의 올바른 위치를 찾을 때까지 `A[j-1],A[j-2],...` 오른쪽으로 한칸씩 swap. `j`가 `1`씩 증가하면서 다음 반복에서 루프 불변성이 유지된다.
- 종료 조건: `j`가 `n + 1`일 때 for 루프가 종료되는데, 이때 A[1..n]은 정렬된 상태이므로 이 알고리즘은 타당하다.


```kotlin
fun <T> Collection<T>.insertionSort(compare: (T, T) -> Boolean): Collection<T> {
        val result = ArrayList<T>()
        this.forEach { element ->
            try {
                if (result.isEmpty()) result.add(element)
                else result.add(result.indexOf(result.first { compare(it, element) }), element)
            } catch (e: NoSuchElementException) {
                result.add(element)
            }
        }
        return result
    }
```

```kotlin
fun main(args: Array<String>) {
    val arr = arrayListOf(0, 3, 67, 4, 10, 6, 9, 100, 2, 98)
        val result = arr.insertionSort { a, b -> a > b }
        println("$result")
}
```

```
[0, 2, 3, 4, 6, 9, 10, 67, 98, 100]
```

##### 알고리즘의 분석
- 알고리즘 수행 상황 정의: 단일 프로세서 + 랜덤 접근 기계(RAM) (명령어 순차적 실행)
- RAM
	- 산술연산(덧셈, 뺄셈, 곱셈, 나눗셈, 나머지, 올림, 내림), 데이터 이동(CRU), 제어 연산(조건분기, 무조건분기, 함수 호출, 리턴)에는 상수 시간이 걸린다.
	- 메모리 계층을 고려하지 않는다. (캐시, 가상 메모리 포함 X)

##### 입력 크기: 문제마다 다르다
- 입력 항목의 개수 (배열의 크기)
- 입력을 이진수로 표현했을 때 필요한 비트수
- 하나의 입력을 두개의 값으로 표현할 경우 (그래프의 노드와 간선)

##### 수행 시간
- 기본 연산 개수
- 실행 단계의 횟수
- 각 행을 수행하는 데 상수시간이 소요된다고 정의하자

#### 삽입 정렬의 분석
- 입력이 많을 수록 오래 걸린다. 
- 같은 입력이라도 초기에 얼마나 정렬되어 있느냐에 따라 수행시간이 달라진다.

1. 최선의 상황
- 입력 자체로 정렬이 되어있는 상황
- while문이 실행되지 않는다.
- 1,2,4,5,8행이 n번 수행된다 -> n에 관한 선형 함수

2. 최악의 상황
- 역순으로 정렬이 되어있는 상황
- 모든 비교와 모든 swap을 해야함
- 하나의 n에 대해 5,6,7행은 n번 수행되므로 -> n에 관한 이차식

3. 평균적인 상황
- 원소의 절반이 A[j]보다 값이 작은 상황
- 그래도 절반의 n에 대해서 5,6,7행이 실행되므로 -> n에 관한 이차식

##### 시간 복잡도를 책정할 땐 최악의 상황으로 가정한다.
1. 최악의 경우의 수행시간이 모든 상황의 상한선이다. 이보다 더 오래걸리지 않는다.
2. 어떤 알고리즘은 최악의 경우가 자주 발생할 수 있다. (검색 알고리즘에서 없는 것을 찾을 경우)
3. "평균적인 경우"가 최악 만큼 좋지 못한 상황일 때가 있다. (삽입 정렬의 경우 최악, 평균의 상황 모두 이차식을 가지므로 비슷한 시간이 걸린다.)

##### 증가차수
- 모든 알고리즘에 대해 명령문의 비용을 계산하는일은 매우 복잡하다.
- 좀 더 단순히 계산하기 위해 **증가 비율** 또는 **증가 차수**를 사용
- 차수가 낮은 항은 상대적으로 덜 중요하다.
- 상수 계수도 증가 비율에 영향을 별로 못 미치기 때문에 덜 중요하다.
- **최고차항만 남긴다.**
- 더 낮은 증가차수를 가진 알고리즘이 더 효율적이다.
