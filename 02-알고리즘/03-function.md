# 함수의 증가
- 입력이 충분히 커지면 수행시간 증가의 차수만 중요해진다.
- 알고리즘의 점근적 효율성을 판단할 수 있는 표기법을 살펴본다.
- 알고리즘 분석에 자주 등장하는 함수의 특성을 살펴본다.

## 알고리즘의 수행시간과 점근적 표기법
- 컴퓨터가 알고리즘을 실행하는 속도: CPU속도, 언어, 컴파일러 속도 등
- 알고리즘의 입력 크기: 배열의 크기, 데이터 타입 등
- 실행 시간의 성장률(rate of growth)
	- 입력의 크기에 따라 수행시간이 얼마나 증가하는가
	- 증가하는 비율이 중요하므로 계수와 최고차항이 아닌 항은 중요치 않음
- **점근적 표기법**
	- 성장률에만 집중해 불필요한 항과 계수를 삭제한 표기법
	- 작은 크기의 `n`에 대해선 무시.
	- 입력의 크기가 일정 이상 커지는 것에 대해 초점.
- Θ(log<sub>10</sub> n)과 Θ(log<sub>2</sub> n)처럼 로그의 밑이 상수라면 무엇이든 중요치 않다.

![](../99-images/algorithm_function_00.png)
- 이는 모든 양수에 성립한다.

- 만일 `a`, `b`가 상수라면, log<sub>b</sub> a에 의해서만 달라지기 때문에 점근적 표기법에서 무시할 수 있는 상수이다.

### 알고리즘의 수행속도
- 자주 나오는 함수의 속도의 순서를 알아보자.
- `a` < `b`라면, Θ(n<sup>a</sup>) < Θ(n<sup>b</sup>)
![](../99-images/algorithm_function_01.png)

- Θ(log<sub>2</sub>n)은 Θ(n)보다 느리게 증가한다.
![](../99-images/algorithm_function_02.png)

- 주로 사용하는 함수들의 속도 비교 (오름차순)
	1. Θ(1)
	2. Θ(log<sub>2</sub>n)
	3. Θ(n)
	4. Θ(nlog<sub>2</sub>n)
	5. Θ(n<sup>2</sup>)
	6. Θ(n<sup>2</sup>log<sub>2</sub>n)
	7. Θ(n<sup>3</sup>)
	8. Θ(2<sup>n</sup>)
	9. Θ(n!)


### Big-θ (빅 세타) 표기법
- 입력의 크기가 충분히 크다고 가정한다 (컴퓨터의 속도, 언어 등에 따라 바뀌는 상수 시간의 변화를 무시한다.)
- 알고리즘의 상한선과 하한선을 고려하는 표기법
- 최악의 상황과 최선의 상황을 모두 고려
- `n`의 크기가 충분히 크다면, 알고리즘의 수행속도는 **어느 순간**부터 k<sub>1</sub> * n과 k<sub>2</sub> * n 직선 사이에 끼이게 된다.

![](https://cdn.kastatic.org/ka-perseus-images/c14a48f24cae3fd563cb3627ee2a74f56c0bcef6.png)

- 무조건 k<sub>1</sub> * n과 k<sub>2</sub> * n 직선 사이에 끼이게 되는 최솟점을 n<sub>0</sub>이라 하자.
- n<sub>0</sub> 보다 작은 값들은 입력이 충분히 크지 않으므로 무시한다.
- 그러므로 `running time`은 k<sub>1</sub> * n, k<sub>2</sub> * n 점근적으로 엄밀한 관계에 있다.
- **running time 은 음이 아니다라는 조건이 필요하다** (음이라면, 두 직선 사이에 끼이지 않게 된다.)
- n<sub>0</sub>, k<sub>1</sub>, k<sub>2</sub> 이 세 값을 선택할 수 있다 = **존재한다** 는 점에서 θ(n)으로 표기할 수 있다.

- `n`대신 `f(n)`에 대입할 수 있다.

![](https://www.researchgate.net/publication/272666937/figure/fig1/AS:615090462146562@1523660402942/Pictorial-Representation-of-big-theta.png)


### Big-O (빅 오) 표기법
- 점근적 상한선만 고려
- 항상 최악의 상황이 아님. 더 빠를수도 있음을 고려.
- **실행 시간은 최대 이만큼 커지지만 더 천천히 커질 수도 있다**
- 실행시간이 O(f(n))이라면 실행시간은 최대 k * f(n)
	- 충분히 큰 n에 대해서만 고려
![](https://cdn.kastatic.org/ka-perseus-images/501211c02f4c6765f60f23842450e1151cfd9c89.png)

- 특정 상황에서 실행 시간이 Θ(f(n))이라면, 이는 또한 O(f(n)) 이다.
- 예: 이진 검색은 항상 O(log<sub>2</sub>n) 시간안에 실행되지만, 항상 Θ(log<sub>2</sub>n)에 실행되는 것은 아니다.
- 이진검색이 O(n)이라고 하는 것도 맞는 말이다. 항상 f(n) = cn 보다는 느리게 커지기 때문
	- 하지만, Θ(n), Θ(n<sup>2</sup>), Θ(n<sup>3</sup>)등으로는 이진 검색을 묘사하지 못한다. 하한선이 아니기 때문.
