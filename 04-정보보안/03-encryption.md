# 암호

## 고전 암호
- 암호를 만드는 규칙이 정해져있는 암호
- 예: 알파벳을 3글자씩 민다. "I like cat" -> "L olnh fdw"
- 규칙 자체가 비밀 = 알고리즘이 공개되면 모두가 복호화 가능

## 현대 암호
- 암호를 만드는 규칙(알고리즘) 공개
- key를 감추고, key를 통해 정해진 규칙대로 암호화

### 1. 공통키(대칭키) 암호화
- 암호화, 복호화 key가 똑같음
- **보안의 강도 = key의 길이**
- 최소 112비트
- key가 똑같기 때문에 암호화 이전에 송, 수신 측이 key를 교환해야 한다
- 키 배송 문제: 네트워크 연결에서 key를 유출당하면 안되므로 key를 또 암호화 해야 하는 문제
- 예: AES(128bit 이상), DES(56bit key)

#### 1) 주로 사용하는 상황
1. 키를 갖고 있는 본인만 복호화하는 경우
2. 고속으로 암복호화를 해야하는 경우
3. 송신자와 수신자가 일대일 통신으로 키를 공유할 수 있는 경우
4. 대량의 데이터를 암호화하고 싶은 경우

#### 2) 공격 방법
1. 선형 공격(linear cryptanalysis)
	- 평문과 암호문의 XOR과 key의 XOR이 선형 관계성을 가진다고 가정하고 관계식을 찾는 공격법
2. 차분 공격(differential cryptanalysis)
	- 비슷한 평문 2개를 XOR한 차이와, 그 평문을 암호화한 결과 2개를 XOR한 차이 2개 사이의 관계를 계산하는 공격법
3. 브루트 포스 공격
	- 무차별 대입 공격 (평균적으로 전체 경우의 수의 1/2이면 해독)

#### 3) AES
- 현재 암호 규격에 의해 이용이 권장되는 공통키 암호 방식(안전성, 비용, 알고리즘 및 구현 특성 평가)
- 1999년에 DES 암호를 해독하는데 22시간이 걸리면서 새로운 알고리즘에 대한 수요가 생김
- key의 길이는 최소 128 (192, 256)
- key가 길수록 안전성은 강화되지만 그만큼 암복호화에 시간이 오래 걸린다
- 예: wifi의 암호화 구격인 WPA2(AES 사용), 인터넷의 TLS(AES 사용)

	##### TLS
	- SSL1.0 또는 SSL3.0의 다음 버전
	- 인터넷에서 통신할 때 인증 및 통신 암호화
	- 1. **통신할 상대방**이 신뢰할 만한지 인증 (Handshake 프로토콜: 상대가 갖고 있는 인증서를 받아 상대방을 검증)
	- 2. 보낼 데이터 암호화
	- OpenSSL: SSL/TLS를 구축한 오픈 소스 (Heartbleed: OpenSSL의 TLS 구축 방법 문제로 시스템상 메모리에서 평문 데이터를 참조할 수 있는 문제가 2013년 발생)
	
		- Handshake Protocol
			1. Client -> Server: 사용할 수 있는 암호 알고리즘 제시
			2. Client <- Server: 알고리즘 결정
			3. Client <- Server: 인증서(공개키) 전송
			4. Client -> Server: 인증서 검증 후, 프리 마스터 키를 공개키로 암호화하여 전송
			5. Client -> Server: 프리 마스터 키로 공통키 생성 완료하고 준비가 끝났음을 알림
			6. Client <- Server: 프리 마스터 키를 비밀키로 복호화하여 공통키를 생성 완료하고 준비가 끝났음을 알림
			7. 암호화 통신 시작


### 2. 공개키 암호화
- key 2개를 사용해 암복호화 -> 암호화: 공개키, 복호화: 비밀키
- 키 관리의 편리함 (공개키가 유출되어도 복호화하지 못함)
- **보안의 강도 = 각 알고리즘의 수학적 성질**
- 예: RSA(큰 2개의 소수는 소인수분해가 어렵다) -> 간단히 소인수분해가 가능해지면 RSA는 안전하지 않게 된다